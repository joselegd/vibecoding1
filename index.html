<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>In Tandem</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Share+Tech+Mono&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a0f;
    color: #fff;
    font-family: 'Share Tech Mono', monospace;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
  }

  /* ===== SCREENS ===== */
  .screen {
    position: absolute;
    inset: 0;
    display: none;
    justify-content: center;
    align-items: center;
    flex-direction: column;
  }
  .screen.active { display: flex; }

  /* ===== TITLE SCREEN ===== */
  #titleScreen {
    background: radial-gradient(ellipse at 50% 40%, #1a1a3e 0%, #0a0a0f 70%);
  }
  #titleScreen::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image:
      repeating-linear-gradient(0deg, transparent, transparent 39px, rgba(255,255,255,0.03) 39px, rgba(255,255,255,0.03) 40px),
      repeating-linear-gradient(90deg, transparent, transparent 39px, rgba(255,255,255,0.03) 39px, rgba(255,255,255,0.03) 40px);
  }
  .title-text {
    font-family: 'Press Start 2P', monospace;
    font-size: clamp(28px, 5vw, 56px);
    color: #fff;
    text-shadow: 0 0 20px #7b5ea7, 0 0 60px #7b5ea7, 4px 4px 0 #3d2b5a;
    letter-spacing: 4px;
    margin-bottom: 16px;
    animation: pulse 3s ease-in-out infinite;
  }
  .title-sub {
    font-size: 12px;
    color: #7b5ea7;
    letter-spacing: 6px;
    text-transform: uppercase;
    margin-bottom: 60px;
  }
  @keyframes pulse {
    0%,100% { text-shadow: 0 0 20px #7b5ea7, 0 0 60px #7b5ea7, 4px 4px 0 #3d2b5a; }
    50% { text-shadow: 0 0 40px #a07dd0, 0 0 100px #a07dd0, 4px 4px 0 #3d2b5a; }
  }
  .btn-group { display: flex; flex-direction: column; gap: 16px; align-items: center; }
  .btn {
    font-family: 'Press Start 2P', monospace;
    font-size: 13px;
    padding: 14px 36px;
    background: transparent;
    border: 2px solid #7b5ea7;
    color: #d4b8ff;
    cursor: pointer;
    letter-spacing: 2px;
    transition: all 0.15s;
    min-width: 220px;
    position: relative;
    overflow: hidden;
  }
  .btn::after {
    content: '';
    position: absolute;
    inset: 0;
    background: #7b5ea7;
    transform: translateX(-101%);
    transition: transform 0.15s;
    z-index: -1;
  }
  .btn:hover { color: #fff; border-color: #d4b8ff; }
  .btn:hover::after { transform: translateX(0); }
  .btn:active { transform: scale(0.97); }
  .btn.red { border-color: #e05555; color: #ffaaaa; }
  .btn.red::after { background: #e05555; }
  .btn.red:hover { border-color: #ff8888; }

  /* ===== TUTORIAL SCREEN ===== */
  #tutorialScreen {
    background: radial-gradient(ellipse at 50% 40%, #0d1a2e 0%, #0a0a0f 70%);
  }
  .tutorial-box {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.1);
    padding: 40px 50px;
    max-width: 700px;
    width: 90%;
  }
  .tutorial-box h2 {
    font-family: 'Press Start 2P', monospace;
    font-size: 16px;
    color: #7b5ea7;
    margin-bottom: 30px;
    text-align: center;
    letter-spacing: 3px;
  }
  .tutorial-cols { display: flex; gap: 40px; margin-bottom: 30px; }
  .tutorial-col { flex: 1; }
  .tutorial-col h3 {
    font-family: 'Press Start 2P', monospace;
    font-size: 10px;
    color: #4fc3f7;
    margin-bottom: 14px;
    border-bottom: 1px solid rgba(79,195,247,0.3);
    padding-bottom: 8px;
  }
  .key-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 12px; color: #ccc; }
  .key {
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.25);
    border-bottom: 3px solid rgba(255,255,255,0.15);
    padding: 4px 10px;
    border-radius: 4px;
    font-family: 'Press Start 2P', monospace;
    font-size: 9px;
    color: #fff;
    min-width: 34px;
    text-align: center;
  }
  .tutorial-overview {
    font-size: 11px;
    color: #aaa;
    line-height: 1.9;
    border-top: 1px solid rgba(255,255,255,0.1);
    padding-top: 20px;
  }
  .tutorial-overview span { color: #d4b8ff; }

  /* ===== CONTINUE SCREEN ===== */
  #continueScreen {
    background: radial-gradient(ellipse at 50% 40%, #0a1a0d 0%, #0a0a0f 70%);
  }
  .continue-box {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.1);
    padding: 50px;
    text-align: center;
    min-width: 340px;
  }
  .continue-box h2 {
    font-family: 'Press Start 2P', monospace;
    font-size: 14px;
    color: #7b5ea7;
    margin-bottom: 30px;
    letter-spacing: 2px;
  }
  .level-input {
    font-family: 'Press Start 2P', monospace;
    font-size: 24px;
    width: 100px;
    text-align: center;
    background: rgba(255,255,255,0.06);
    border: 2px solid #7b5ea7;
    color: #fff;
    padding: 12px;
    margin-bottom: 20px;
    outline: none;
  }
  .level-input:focus { border-color: #d4b8ff; }

  /* ===== GAME SCREEN ===== */
  #gameScreen {
    background: #0a0a0f;
    flex-direction: row;
    align-items: stretch;
  }
  .game-half {
    flex: 1;
    position: relative;
    overflow: hidden;
  }
  .game-half canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
  .divider {
    width: 4px;
    background: linear-gradient(to bottom, transparent, #7b5ea7, #4fc3f7, #7b5ea7, transparent);
    flex-shrink: 0;
    position: relative;
  }
  .divider::after {
    content: 'IN TANDEM';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(90deg);
    font-family: 'Press Start 2P', monospace;
    font-size: 8px;
    color: rgba(255,255,255,0.2);
    letter-spacing: 4px;
    white-space: nowrap;
  }
  .hud {
    position: absolute;
    top: 12px;
    right: 12px;
    font-family: 'Press Start 2P', monospace;
    font-size: 10px;
    color: rgba(255,255,255,0.6);
    text-align: right;
    z-index: 10;
    pointer-events: none;
  }
  .timer-hud {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Press Start 2P', monospace;
    font-size: 14px;
    color: #fff;
    z-index: 10;
    pointer-events: none;
    text-shadow: 0 0 10px #7b5ea7;
    white-space: nowrap;
  }
  .timer-hud.danger { color: #ff5555; text-shadow: 0 0 10px #ff5555; animation: blink 0.5s step-end infinite; }
  @keyframes blink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

  .player-label {
    position: absolute;
    top: 12px;
    left: 12px;
    font-family: 'Press Start 2P', monospace;
    font-size: 9px;
    color: rgba(255,255,255,0.4);
    z-index: 10;
    pointer-events: none;
  }

  /* ===== DEATH SCREEN ===== */
  #deathScreen {
    background: rgba(0,0,0,0.92);
    z-index: 100;
  }
  .death-content {
    position: relative;
    z-index: 2;
    text-align: center;
  }
  .you-died {
    font-family: 'Press Start 2P', monospace;
    font-size: clamp(32px, 6vw, 72px);
    color: #e05555;
    text-shadow: 0 0 30px #e05555, 0 0 80px #e05555, 6px 6px 0 #7a0000;
    margin-bottom: 16px;
    animation: deathPulse 1.5s ease-in-out infinite;
  }
  @keyframes deathPulse {
    0%,100% { text-shadow: 0 0 30px #e05555, 0 0 80px #e05555, 6px 6px 0 #7a0000; }
    50% { text-shadow: 0 0 60px #ff3333, 0 0 120px #ff3333, 6px 6px 0 #7a0000; }
  }
  .death-reason {
    font-size: 12px;
    color: #aaa;
    margin-bottom: 40px;
    letter-spacing: 3px;
  }
  #owlBounce {
    position: absolute;
    width: 120px;
    height: 120px;
    object-fit: contain;
    user-select: none;
    pointer-events: none;
    opacity: 0.35;
    filter: grayscale(30%);
    z-index: 1;
  }

  /* ===== WIN SCREEN ===== */
  #winScreen {
    background: radial-gradient(ellipse at 50% 50%, #0d2a0d 0%, #0a0a0f 70%);
    z-index: 100;
  }
  .win-title {
    font-family: 'Press Start 2P', monospace;
    font-size: clamp(24px, 4vw, 48px);
    color: #55e078;
    text-shadow: 0 0 30px #55e078, 0 0 80px #55e078;
    margin-bottom: 16px;
    animation: winPulse 2s ease-in-out infinite;
  }
  @keyframes winPulse {
    0%,100% { text-shadow: 0 0 30px #55e078, 0 0 80px #55e078; }
    50% { text-shadow: 0 0 60px #88ffaa, 0 0 120px #88ffaa; }
  }

  /* ===== COMPLETE SCREEN ===== */
  #completeScreen {
    background: radial-gradient(ellipse at 50% 50%, #2a1a0d 0%, #0a0a0f 70%);
    z-index: 100;
  }
  .complete-title {
    font-family: 'Press Start 2P', monospace;
    font-size: clamp(20px, 3.5vw, 40px);
    color: #ffd700;
    text-shadow: 0 0 30px #ffd700, 0 0 80px #ffd700;
    margin-bottom: 16px;
    text-align: center;
  }
</style>
</head>
<body>

<!-- TITLE SCREEN -->
<div id="titleScreen" class="screen active">
  <div class="title-text">In Tandem</div>
  <div class="title-sub">a parallel platformer</div>
  <div class="btn-group">
    <button class="btn" onclick="startGame(1)">▶ Start</button>
    <button class="btn" onclick="showContinue()">⏩ Continue Game</button>
    <button class="btn" onclick="showTutorial()">? Tutorial</button>
  </div>
</div>

<!-- TUTORIAL SCREEN -->
<div id="tutorialScreen" class="screen">
  <div class="tutorial-box">
    <h2>How to Play</h2>
    <div class="tutorial-cols">
      <div class="tutorial-col">
        <h3>Left Player</h3>
        <div class="key-row"><span class="key">W</span> Jump</div>
        <div class="key-row"><span class="key">A</span> Move Left</div>
        <div class="key-row"><span class="key">D</span> Move Right</div>
        <div class="key-row" style="margin-top:8px; color:#888; font-size:11px;">Press W twice to double-jump</div>
      </div>
      <div class="tutorial-col">
        <h3>Right Player</h3>
        <div class="key-row"><span class="key">↑</span> Jump</div>
        <div class="key-row"><span class="key">←</span> Move Left</div>
        <div class="key-row"><span class="key">→</span> Move Right</div>
        <div class="key-row" style="margin-top:8px; color:#888; font-size:11px;">Press ↑ twice to double-jump</div>
      </div>
    </div>
    <div class="tutorial-overview">
      In this game, you are playing as a guide for two beings who are fundamentally interlinked. You must guide <span>BOTH</span> of them at the same time through a series of <span>five labyrinths</span>. But hurry, your time is limited. You only have <span>10 minutes</span> to get through. If that's not enough, pick up the <span>clock icons</span> along the way for an extra minute. There is one per side of each level. Pick up both of them for an extra <span>30 second bonus</span>. If you run out of time, you die. You will also perish if you touch a <span>spike</span> or fall into the <span>void</span>. Good luck!
    </div>
    <div style="margin-top:24px; text-align:center;">
      <button class="btn" onclick="showScreen('titleScreen')">← Back</button>
    </div>
  </div>
</div>

<!-- CONTINUE SCREEN -->
<div id="continueScreen" class="screen">
  <div class="continue-box">
    <h2>Continue Game</h2>
    <div style="font-size:11px; color:#888; margin-bottom:20px;">Enter level number (1–5)</div>
    <input type="number" class="level-input" id="continueInput" min="1" max="5" value="1">
    <br>
    <button class="btn" onclick="continueFromLevel()" style="margin-bottom:12px;">▶ Go</button>
    <br>
    <button class="btn" onclick="showScreen('titleScreen')">← Back</button>
  </div>
</div>

<!-- GAME SCREEN -->
<div id="gameScreen" class="screen">
  <div class="game-half" id="leftHalf">
    <canvas id="leftCanvas"></canvas>

    <div class="hud" id="leftHud"></div>
  </div>
  <div class="divider"></div>
  <div class="game-half" id="rightHalf">
    <canvas id="rightCanvas"></canvas>

    <div class="hud" id="rightHud"></div>
  </div>
  <div class="timer-hud" id="timerHud">5:00</div>
</div>

<!-- DEATH SCREEN -->
<div id="deathScreen" class="screen">
  <img id="owlBounce" src="disappointed_owl.png" alt="disappointed owl">
  <div class="death-content">
    <div class="you-died">You Died</div>
    <div class="death-reason" id="deathReason">touched a spike</div>
    <div class="btn-group">
      <button class="btn" onclick="retryLevel()">↩ Try Again</button>
      <button class="btn red" onclick="showScreen('titleScreen')">✕ Quit</button>
    </div>
  </div>
</div>

<!-- WIN SCREEN (level complete) -->
<div id="winScreen" class="screen">
  <div class="win-title">Level Clear!</div>
  <div style="font-size:12px; color:#aaa; margin-bottom:40px; letter-spacing:3px;">both players escaped</div>
  <button class="btn" id="nextLevelBtn" onclick="nextLevel()">▶ Next Level</button>
</div>

<!-- COMPLETE SCREEN -->
<div id="completeScreen" class="screen">
  <div class="complete-title">You made it!</div>
  <div style="font-size:11px; color:#aaa; margin:20px 0 40px; letter-spacing:3px; text-align:center;">both beings are free</div>
  <div class="btn-group">
    <button class="btn" onclick="playAgain()">▶ Play Again</button>
    <button class="btn" onclick="showScreen('titleScreen')">⌂ Title Screen</button>
  </div>
</div>

<script>
// ===== UTILITY =====
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function showTutorial() { showScreen('tutorialScreen'); }
function showContinue() { showScreen('continueScreen'); }
function continueFromLevel() {
  let v = parseInt(document.getElementById('continueInput').value);
  if (isNaN(v) || v < 1) v = 1;
  if (v > 5) v = 5;
  startGame(v);
}

// ===== OWL BOUNCE =====
let owlX = 50, owlY = 50, owlVX = 2.5, owlVY = 2.2, owlAnim = null;
function startOwlBounce() {
  const owl = document.getElementById('owlBounce');
  owlX = Math.random() * (window.innerWidth - 120);
  owlY = Math.random() * (window.innerHeight - 120);
  owlVX = (Math.random() > 0.5 ? 1 : -1) * (2 + Math.random() * 2);
  owlVY = (Math.random() > 0.5 ? 1 : -1) * (2 + Math.random() * 2);
  if (owlAnim) cancelAnimationFrame(owlAnim);
  function step() {
    if (!document.getElementById('deathScreen').classList.contains('active')) return;
    owlX += owlVX;
    owlY += owlVY;
    const W = window.innerWidth - 100, H = window.innerHeight - 100;
    if (owlX < 0) { owlX = 0; owlVX *= -1; }
    if (owlX > W) { owlX = W; owlVX *= -1; }
    if (owlY < 0) { owlY = 0; owlVY *= -1; }
    if (owlY > H) { owlY = H; owlVY *= -1; }
    owl.style.left = owlX + 'px';
    owl.style.top = owlY + 'px';
    owlAnim = requestAnimationFrame(step);
  }
  step();
}

// ===== AUDIO =====
let deathAudio = null;
function playDeathSound() {
  try {
    if (!deathAudio) deathAudio = new Audio('death_sound.mp3');
    deathAudio.currentTime = 0;
    deathAudio.play().catch(() => {});
  } catch(e) {}
}

// ===== GAME STATE =====
let currentLevel = 1;
let gameRunning = false;
let timerSeconds = 600;
let timerInterval = null;
let leftGame = null, rightGame = null;
let leftDone = false, rightDone = false;

// ===== LEVEL DEFINITIONS =====
// Each level has platforms, spikes defined in a 800x500 grid
// We'll define base layouts, then randomize orientation + exit per side

const LEVEL_DEFS = [
  // Level 1 - Simple intro
  {
    bg: '#1a1a2e',
    ground: '#2d4a8a',
    playerColor: '#e8d44d',
    platforms: [
      {x:0,y:460,w:800,h:40},        // ground
      {x:100,y:360,w:120,h:18},
      {x:300,y:290,w:120,h:18},
      {x:500,y:220,w:120,h:18},
      {x:650,y:300,w:120,h:18},
    ],
    spikes: [
      {x:240,y:452,count:5},
      {x:450,y:452,count:4},
    ],
    spawn: {x:40, y:420},
  },
  // Level 2 - Gaps
  {
    bg: '#1e2a1e',
    ground: '#3a7a3a',
    playerColor: '#f07030',
    platforms: [
      {x:0,y:460,w:200,h:40},
      {x:280,y:460,w:180,h:40},
      {x:540,y:460,w:260,h:40},
      {x:150,y:340,w:140,h:18},
      {x:380,y:300,w:100,h:18},
      {x:560,y:260,w:130,h:18},
      {x:320,y:200,w:100,h:18},
      {x:100,y:250,w:100,h:18},
    ],
    spikes: [
      {x:210,y:490,count:7,onFloor:true,floating:true,fy:500},
      {x:430,y:452,count:3},
      {x:620,y:452,count:4},
      {x:160,y:330,count:3,onPlatform:true,py:340},
    ],
    spawn: {x:30, y:415},
  },
  // Level 3 - Vertical challenge
  {
    bg: '#2a1a2a',
    ground: '#7a3a7a',
    playerColor: '#4fc3f7',
    platforms: [
      {x:0,y:460,w:200,h:40},
      {x:200,y:380,w:80,h:18},
      {x:100,y:300,w:80,h:18},
      {x:200,y:220,w:100,h:18},
      {x:350,y:160,w:130,h:18},
      {x:520,y:220,w:80,h:18},
      {x:620,y:300,w:80,h:18},
      {x:500,y:380,w:120,h:18},
      {x:600,y:460,w:200,h:40},
    ],
    spikes: [
      {x:290,y:452,count:6},
      {x:130,y:292,count:2,onPlatform:true,py:300},
      {x:540,y:212,count:2,onPlatform:true,py:220},
      {x:640,y:452,count:3},
    ],
    spawn: {x:40, y:415},
  },
  // Level 4 - Dense obstacles
  {
    bg: '#2a1a0a',
    ground: '#8a5a20',
    playerColor: '#ff6b9d',
    platforms: [
      {x:0,y:460,w:140,h:40},
      {x:200,y:420,w:80,h:20},
      {x:340,y:380,w:80,h:20},
      {x:480,y:340,w:80,h:20},
      {x:600,y:300,w:80,h:20},
      {x:480,y:240,w:80,h:20},
      {x:340,y:200,w:80,h:20},
      {x:200,y:160,w:80,h:20},
      {x:60,y:200,w:80,h:20},
      {x:0,y:140,w:120,h:20},
      {x:150,y:80,w:500,h:20},
      {x:660,y:460,w:140,h:40},
    ],
    spikes: [
      {x:150,y:452,count:5},
      {x:290,y:452,count:5},
      {x:430,y:452,count:3},
      {x:215,y:411,count:2,onPlatform:true,py:420},
      {x:360,y:371,count:2,onPlatform:true,py:380},
      {x:500,y:331,count:2,onPlatform:true,py:340},
    ],
    spawn: {x:30, y:415},
  },
  // Level 5 - Final gauntlet
  {
    bg: '#0a0a1e',
    ground: '#303080',
    playerColor: '#ffd700',
    platforms: [
      {x:0,y:460,w:120,h:40},
      {x:180,y:430,w:70,h:20},
      {x:310,y:395,w:70,h:20},
      {x:440,y:360,w:70,h:20},
      {x:570,y:320,w:70,h:20},
      {x:680,y:280,w:120,h:20},
      {x:560,y:220,w:80,h:20},
      {x:420,y:200,w:80,h:20},
      {x:280,y:200,w:80,h:20},
      {x:140,y:200,w:80,h:20},
      {x:0,y:200,w:100,h:20},
      {x:80,y:130,w:100,h:20},
      {x:240,y:130,w:80,h:20},
      {x:400,y:130,w:80,h:20},
      {x:560,y:130,w:80,h:20},
      {x:680,y:130,w:120,h:20},
      {x:300,y:60,w:200,h:20},
    ],
    spikes: [
      {x:130,y:452,count:4},
      {x:260,y:452,count:4},
      {x:390,y:452,count:4},
      {x:510,y:452,count:3},
      {x:620,y:452,count:3},
      {x:190,y:421,count:2,onPlatform:true,py:430},
      {x:450,y:351,count:2,onPlatform:true,py:360},
      {x:580,y:211,count:2,onPlatform:true,py:220},
      {x:100,y:191,count:2,onPlatform:true,py:200},
      {x:250,y:121,count:2,onPlatform:true,py:130},
      {x:570,y:121,count:2,onPlatform:true,py:130},
    ],
    spawn: {x:30, y:415},
  },
];

// ===== GAME CLASS =====
class PlatformerSide {
  constructor(canvas, levelDef, mirror, exitSide, controls) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.levelDef = levelDef;
    this.mirror = mirror; // flip X
    this.exitSide = exitSide; // 'left' or 'right'
    this.controls = controls;
    this.done = false;
    this.dead = false;
    this.deathReason = '';

    this.W = 800;
    this.H = 500;

    this.buildLevel();
    this.resetPlayer();
    this.keys = {};
    this._onKey = (e) => this.handleKey(e);
    window.addEventListener('keydown', this._onKey);
    window.addEventListener('keyup', this._onKey);
  }

  buildLevel() {
    const def = this.levelDef;
    this.bg = def.bg;
    this.playerColor = def.playerColor;

    // Transform platforms based on mirror
    this.platforms = def.platforms.map(p => this.transformRect(p));
    this.spikesData = [];

    // Place spikes
    def.spikes.forEach(sd => {
      let sx = sd.x, sy = sd.y;
      const cnt = sd.count || 3;
      const spikeW = 16;
      for (let i = 0; i < cnt; i++) {
        let rx = sx + i * spikeW;
        let ry = sy;
        if (this.mirror) {
          rx = this.W - rx - spikeW;
        }
        this.spikesData.push({x: rx, y: ry, w: spikeW, h: 14});
      }
    });

    // Exit portal - place on a platform on chosen side
    const exitPlat = this.findExitPlatform();
    this.exit = exitPlat;

    // Clock pickup - random platform, not the ground, not same as exit platform
    this.clock = this.placeClock();
    this.clockCollected = false;
    this.clockPopups = []; // floating text animations
  }

  placeClock() {
    // Eligible platforms: not ground (y < 440), has enough width
    const eligible = this.platforms.filter(p => p.y < 440 && p.w >= 40);
    if (eligible.length === 0) {
      // fallback: somewhere safe mid-air
      return {x: this.W / 2 - 12, y: 200, w: 24, h: 24};
    }
    // Pick randomly - use a seeded-ish pick based on mirror flag for variety
    const idx = Math.floor(Math.random() * eligible.length);
    const plat = eligible[idx];
    // Place near center of platform horizontally, sitting on top
    const cx = plat.x + Math.floor(Math.random() * Math.max(1, plat.w - 30));
    return {x: cx, y: plat.y - 26, w: 24, h: 24};
  }

  findExitPlatform() {
    // Filter platform candidates (not the ground, not tiny)
    const plats = this.platforms.filter(p => p.y < 440 && p.w >= 60);
    const side = this.exitSide;

    let best;
    if (plats.length > 0) {
      if (side === 'right') {
        best = plats.reduce((a,b) => (a.x + a.w > b.x + b.w ? a : b));
      } else {
        best = plats.reduce((a,b) => (a.x < b.x ? a : b));
      }
    }

    if (!best) {
      // fallback: use ground on appropriate side
      const gnd = this.platforms.find(p => p.y >= 440);
      if (gnd) {
        best = gnd;
      } else {
        return {x: side === 'right' ? 700 : 50, y: 420, w: 40, h: 30};
      }
    }

    const ex = side === 'right' ? (best.x + best.w - 40) : best.x;
    return {x: ex, y: best.y - 38, w: 32, h: 38};
  }

  transformRect(r) {
    if (this.mirror) {
      return {x: this.W - r.x - r.w, y: r.y, w: r.w, h: r.h};
    }
    return {...r};
  }

  resetPlayer() {
    const spawn = this.levelDef.spawn;
    let sx = spawn.x;
    if (this.mirror) sx = this.W - sx - 24;
    this.player = {
      x: sx, y: spawn.y,
      w: 24, h: 24,
      vx: 0, vy: 0,
      onGround: false,
      jumpsLeft: 2,
    };
    this.done = false;
    this.dead = false;
  }

  handleKey(e) {
    const down = e.type === 'keydown';
    const c = this.controls;
    if (e.code === c.left) this.keys.left = down;
    if (e.code === c.right) this.keys.right = down;
    if (e.code === c.jump || e.code === c.jump2) this.keys.jump = down;
    if (down && (e.code === c.jump || e.code === c.jump2)) this.keys.jumpPressed = true;
  }

  update(dt) {
    if (this.done || this.dead) return;
    const p = this.player;
    const speed = 200;
    const gravity = 900;
    const jumpForce = -340;

    // Horizontal
    p.vx = 0;
    if (this.keys.left) p.vx = -speed;
    if (this.keys.right) p.vx = speed;

    // Jump
    if (this.keys.jumpPressed) {
      this.keys.jumpPressed = false;
      if (p.jumpsLeft > 0) {
        p.vy = jumpForce;
        p.jumpsLeft--;
        p.onGround = false;
      }
    }

    p.vy += gravity * dt;
    p.vy = Math.min(p.vy, 700);

    // Move X
    p.x += p.vx * dt;
    p.x = Math.max(0, Math.min(this.W - p.w, p.x));

    // Collide platforms X (push out)
    this.platforms.forEach(pl => {
      if (this.rectsOverlap(p, pl)) {
        if (p.vx > 0) p.x = pl.x - p.w;
        else if (p.vx < 0) p.x = pl.x + pl.w;
      }
    });

    // Move Y
    p.onGround = false;
    p.y += p.vy * dt;

    this.platforms.forEach(pl => {
      if (this.rectsOverlap(p, pl)) {
        if (p.vy > 0) {
          p.y = pl.y - p.h;
          p.vy = 0;
          p.onGround = true;
          p.jumpsLeft = 2;
        } else if (p.vy < 0) {
          p.y = pl.y + pl.h;
          p.vy = 0;
        }
      }
    });

    // Off bottom = dead
    if (p.y > this.H + 50) {
      this.triggerDeath('fell into the void');
      return;
    }

    // Spike collision
    for (const sp of this.spikesData) {
      if (this.rectsOverlap(p, {x: sp.x + 2, y: sp.y, w: sp.w - 4, h: sp.h})) {
        this.triggerDeath('touched a spike');
        return;
      }
    }

    // Clock pickup
    if (!this.clockCollected) {
      const ck = this.clock;
      if (this.rectsOverlap(p, ck)) {
        this.clockCollected = true;
        this.clockPopups.push({x: ck.x + ck.w/2, y: ck.y, life: 1.5});
        if (this.onClockCollected) this.onClockCollected();
      }
    }

    // Tick popups
    this.clockPopups = this.clockPopups.filter(pop => {
      pop.y -= 40 * dt;
      pop.life -= dt;
      return pop.life > 0;
    });

    // Exit collision
    const ex = this.exit;
    if (p.x < ex.x + ex.w && p.x + p.w > ex.x && p.y < ex.y + ex.h && p.y + p.h > ex.y) {
      this.done = true;
    }
  }

  rectsOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x &&
           a.y < b.y + b.h && a.y + a.h > b.y;
  }

  triggerDeath(reason) {
    this.dead = true;
    this.deathReason = reason;
  }

  destroy() {
    window.removeEventListener('keydown', this._onKey);
    window.removeEventListener('keyup', this._onKey);
  }

  draw() {
    const ctx = this.ctx;
    const W = this.W, H = this.H;
    ctx.save();

    // Background
    ctx.fillStyle = this.bg;
    ctx.fillRect(0, 0, W, H);

    // Grid subtle
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    for (let x = 0; x < W; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
    for (let y = 0; y < H; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }

    // Platforms
    this.platforms.forEach(p => {
      ctx.fillStyle = '#3a6fbf';
      ctx.fillRect(p.x, p.y, p.w, p.h);
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillRect(p.x, p.y, p.w, 3);
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(p.x, p.y + p.h - 3, p.w, 3);
      // Edge detail
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(p.x, p.y + 3, p.w, p.h - 6);
    });

    // Exit portal
    const ex = this.exit;
    const t = Date.now() / 1000;
    // Glow
    const grd = ctx.createRadialGradient(ex.x + ex.w/2, ex.y + ex.h/2, 2, ex.x + ex.w/2, ex.y + ex.h/2, ex.w * 1.5);
    grd.addColorStop(0, `rgba(80,255,120,${0.3 + 0.1 * Math.sin(t*3)})`);
    grd.addColorStop(1, 'rgba(80,255,120,0)');
    ctx.fillStyle = grd;
    ctx.fillRect(ex.x - ex.w, ex.y - ex.h, ex.w * 3, ex.h * 3);
    // Portal body
    ctx.fillStyle = `rgba(60,220,90,${0.8 + 0.2 * Math.sin(t*4)})`;
    ctx.fillRect(ex.x, ex.y, ex.w, ex.h);
    ctx.fillStyle = `rgba(120,255,160,${0.6 + 0.2 * Math.sin(t*5)})`;
    ctx.fillRect(ex.x + 4, ex.y + 4, ex.w - 8, ex.h - 8);
    // Label
    ctx.fillStyle = '#fff';
    ctx.font = '9px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('EXIT', ex.x + ex.w/2, ex.y - 6);
    ctx.textAlign = 'left';

    // Spikes
    this.spikesData.forEach(sp => {
      ctx.fillStyle = '#dd4444';
      ctx.beginPath();
      const n = 1;
      for (let i = 0; i < n; i++) {
        const bx = sp.x;
        ctx.moveTo(bx, sp.y + sp.h);
        ctx.lineTo(bx + sp.w/2, sp.y);
        ctx.lineTo(bx + sp.w, sp.y + sp.h);
      }
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#ff6666';
      ctx.beginPath();
      ctx.moveTo(sp.x + 2, sp.y + sp.h);
      ctx.lineTo(sp.x + sp.w/2, sp.y + 4);
      ctx.lineTo(sp.x + sp.w - 2, sp.y + sp.h);
      ctx.closePath();
      ctx.fill();
    });

    // Clock pickup
    if (!this.clockCollected) {
      const ck = this.clock;
      const bob = Math.sin(t * 3) * 3;
      const cx = ck.x + ck.w / 2;
      const cy = ck.y + ck.h / 2 + bob;
      const r = ck.w / 2;
      // Glow
      const cGrd = ctx.createRadialGradient(cx, cy, 1, cx, cy, r * 2.2);
      cGrd.addColorStop(0, `rgba(255,220,50,${0.4 + 0.15 * Math.sin(t * 4)})`);
      cGrd.addColorStop(1, 'rgba(255,220,50,0)');
      ctx.fillStyle = cGrd;
      ctx.beginPath();
      ctx.arc(cx, cy, r * 2.2, 0, Math.PI * 2);
      ctx.fill();
      // Clock face
      ctx.fillStyle = '#ffe033';
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#cc9900';
      ctx.lineWidth = 2;
      ctx.stroke();
      // Clock inner
      ctx.fillStyle = '#fffbe6';
      ctx.beginPath();
      ctx.arc(cx, cy, r - 3, 0, Math.PI * 2);
      ctx.fill();
      // Hour hand
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(-Math.PI/2 + t*0.5) * (r - 6), cy + Math.sin(-Math.PI/2 + t*0.5) * (r - 6));
      ctx.stroke();
      // Minute hand
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(-Math.PI/2 + t*2) * (r - 4), cy + Math.sin(-Math.PI/2 + t*2) * (r - 4));
      ctx.stroke();
      // Center dot
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(cx, cy, 1.5, 0, Math.PI * 2);
      ctx.fill();
      // Label
      ctx.fillStyle = '#ffe033';
      ctx.font = '8px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText('+1:00', cx, ck.y - 4 + bob);
      ctx.textAlign = 'left';
    }

    // Clock popups
    this.clockPopups.forEach(pop => {
      const alpha = Math.min(1, pop.life / 0.5);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#ffe033';
      ctx.font = 'bold 13px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ffaa00';
      ctx.shadowBlur = 10;
      ctx.fillText('+1:00', pop.x, pop.y);
      ctx.restore();
    });

    // Player
    if (!this.dead) {
      const p = this.player;
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(p.x + 3, p.y + p.h + 1, p.w - 6, 4);
      // Body
      ctx.fillStyle = this.playerColor;
      ctx.fillRect(p.x, p.y, p.w, p.h);
      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.fillRect(p.x + 2, p.y + 2, p.w - 4, 6);
      // Eyes
      ctx.fillStyle = '#222';
      ctx.fillRect(p.x + 5, p.y + 7, 4, 4);
      ctx.fillRect(p.x + 15, p.y + 7, 4, 4);
    }

    // Death overlay
    if (this.dead) {
      ctx.fillStyle = 'rgba(180,0,0,0.3)';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = 'rgba(255,80,80,0.8)';
      ctx.font = '20px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText('✕', W/2, H/2);
      ctx.textAlign = 'left';
    }

    // Done overlay
    if (this.done) {
      ctx.fillStyle = 'rgba(0,200,60,0.2)';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = 'rgba(100,255,140,0.9)';
      ctx.font = '14px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText('ESCAPED!', W/2, H/2);
      ctx.textAlign = 'left';
    }

    ctx.restore();
  }
}

// ===== GAME LOOP =====
let rafId = null;
let lastTime = 0;

function refreshTimerHud() {
  const m = Math.floor(timerSeconds / 60);
  const s = timerSeconds % 60;
  const el = document.getElementById('timerHud');
  el.textContent = `${m}:${s.toString().padStart(2,'0')}`;
  el.className = 'timer-hud' + (timerSeconds <= 30 ? ' danger' : '');
}

let bonusFlashTimeout = null;
function showTimerBonus(text) {
  const el = document.getElementById('timerHud');
  const prev = el.textContent;
  el.style.color = '#ffe033';
  el.style.textShadow = '0 0 20px #ffaa00';
  // flash bonus text briefly
  if (bonusFlashTimeout) clearTimeout(bonusFlashTimeout);
  bonusFlashTimeout = setTimeout(() => {
    el.style.color = '';
    el.style.textShadow = '';
  }, 800);
}

function updateTimer() {
  timerSeconds--;
  const m = Math.floor(timerSeconds / 60);
  const s = timerSeconds % 60;
  const el = document.getElementById('timerHud');
  el.textContent = `${m}:${s.toString().padStart(2,'0')}`;
  el.className = 'timer-hud' + (timerSeconds <= 30 ? ' danger' : '');
  if (timerSeconds <= 0) {
    endGame('time ran out');
  }
}

function resizeCanvases() {
  const lh = document.getElementById('leftHalf');
  const lc = document.getElementById('leftCanvas');
  const rc = document.getElementById('rightCanvas');
  const rh = document.getElementById('rightHalf');
  lc.width = lh.clientWidth;
  lc.height = lh.clientHeight;
  rc.width = rh.clientWidth;
  rc.height = rh.clientHeight;
}

function startGame(level) {
  currentLevel = level;
  timerSeconds = 600;
  launchLevel(level);
}

function launchLevel(level) {
  // Stop existing
  if (rafId) cancelAnimationFrame(rafId);
  if (timerInterval) clearInterval(timerInterval);
  if (leftGame) leftGame.destroy();
  if (rightGame) rightGame.destroy();

  showScreen('gameScreen');
  setTimeout(() => {
    resizeCanvases();

    const def = LEVEL_DEFS[level - 1];
    // Randomize per side
    const leftMirror = Math.random() > 0.5;
    const rightMirror = Math.random() > 0.5;
    const leftExit = Math.random() > 0.5 ? 'right' : 'left';
    const rightExit = leftExit === 'right' ? 'left' : 'right';

    leftGame = new PlatformerSide(
      document.getElementById('leftCanvas'),
      def, leftMirror, leftExit,
      {left:'KeyA', right:'KeyD', jump:'KeyW', jump2:'KeyE'}
    );
    rightGame = new PlatformerSide(
      document.getElementById('rightCanvas'),
      def, rightMirror, rightExit,
      {left:'ArrowLeft', right:'ArrowRight', jump:'ArrowUp', jump2:'ShiftRight'}
    );

    // Clock collection callbacks
    let clocksCollected = 0;
    function onClockCollected() {
      timerSeconds += 60;
      clocksCollected++;
      // Both clocks collected: bonus 30 seconds
      if (clocksCollected >= 2) {
        timerSeconds += 30;
        showTimerBonus('+1:30');
      } else {
        showTimerBonus('+1:00');
      }
      refreshTimerHud();
    }
    leftGame.onClockCollected = onClockCollected;
    rightGame.onClockCollected = onClockCollected;

    document.getElementById('leftHud').textContent = `LVL ${level}`;
    document.getElementById('rightHud').textContent = `LVL ${level}`;

    const el = document.getElementById('timerHud');
    const m = Math.floor(timerSeconds / 60);
    const s = timerSeconds % 60;
    el.textContent = `${m}:${s.toString().padStart(2,'0')}`;
    el.className = 'timer-hud' + (timerSeconds <= 30 ? ' danger' : '');

    timerInterval = setInterval(updateTimer, 1000);
    lastTime = performance.now();
    gameRunning = true;

    function loop(now) {
      if (!gameRunning) return;
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;

      const lc = document.getElementById('leftCanvas');
      const rc = document.getElementById('rightCanvas');
      // Scale canvas drawing
      const lCtx = lc.getContext('2d');
      lCtx.save();
      lCtx.scale(lc.width / 800, lc.height / 500);
      leftGame.ctx = lCtx;
      leftGame.update(dt);
      leftGame.draw();
      lCtx.restore();

      const rCtx = rc.getContext('2d');
      rCtx.save();
      rCtx.scale(rc.width / 800, rc.height / 500);
      rightGame.ctx = rCtx;
      rightGame.update(dt);
      rightGame.draw();
      rCtx.restore();

      // Check death
      if (leftGame.dead || rightGame.dead) {
        const reason = leftGame.dead ? leftGame.deathReason : rightGame.deathReason;
        endGame(reason);
        return;
      }

      // Check win
      if (leftGame.done && rightGame.done) {
        winLevel();
        return;
      }

      rafId = requestAnimationFrame(loop);
    }
    rafId = requestAnimationFrame(loop);
  }, 100);
}

function endGame(reason) {
  gameRunning = false;
  if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
  if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
  if (leftGame) leftGame.destroy();
  if (rightGame) rightGame.destroy();

  document.getElementById('deathReason').textContent = reason;
  showScreen('deathScreen');
  playDeathSound();
  startOwlBounce();
}

function winLevel() {
  gameRunning = false;
  if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
  if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
  if (leftGame) leftGame.destroy();
  if (rightGame) rightGame.destroy();

  if (currentLevel >= 5) {
    showScreen('completeScreen');
  } else {
    showScreen('winScreen');
  }
}

function retryLevel() {
  launchLevel(currentLevel);
}

function playAgain() {
  timerSeconds = 600;
  startGame(1);
}

function nextLevel() {
  currentLevel++;
  launchLevel(currentLevel);
}

window.addEventListener('resize', () => {
  if (document.getElementById('gameScreen').classList.contains('active')) {
    resizeCanvases();
  }
});

// Prevent arrow keys scrolling page
window.addEventListener('keydown', e => {
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) {
    e.preventDefault();
  }
});
</script>
</body>
</html>
